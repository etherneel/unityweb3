import{c4 as Ve,cd as fe,ce as Qt,cf as Pe,cg as xt,ch as ae,ci as ue,cj as ze,ck as je,cl as Me,c7 as Ke,c6 as le,cc as vt}from"./index-ce020a9a.js";const Bt=BigInt(2**32-1),Rt=BigInt(32);function de(t,n=!1){return n?{h:Number(t&Bt),l:Number(t>>Rt&Bt)}:{h:Number(t>>Rt&Bt)|0,l:Number(t&Bt)|0}}function he(t,n=!1){let e=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:s,l:c}=de(t[o],n);[e[o],r[o]]=[s,c]}return[e,r]}const Ye=(t,n)=>BigInt(t>>>0)<<Rt|BigInt(n>>>0),De=(t,n,e)=>t>>>e,Ge=(t,n,e)=>t<<32-e|n>>>e,We=(t,n,e)=>t>>>e|n<<32-e,Xe=(t,n,e)=>t<<32-e|n>>>e,Qe=(t,n,e)=>t<<64-e|n>>>e-32,Je=(t,n,e)=>t>>>e-32|n<<64-e,Fe=(t,n)=>n,tn=(t,n)=>t,ge=(t,n,e)=>t<<e|n>>>32-e,we=(t,n,e)=>n<<e|t>>>32-e,be=(t,n,e)=>n<<e-32|t>>>64-e,ye=(t,n,e)=>t<<e-32|n>>>64-e;function en(t,n,e,r){const o=(n>>>0)+(r>>>0);return{h:t+e+(o/2**32|0)|0,l:o|0}}const nn=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),rn=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,on=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),sn=(t,n,e,r,o)=>n+e+r+o+(t/2**32|0)|0,cn=(t,n,e,r,o)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(o>>>0),fn=(t,n,e,r,o,s)=>n+e+r+o+s+(t/2**32|0)|0,an={fromBig:de,split:he,toBig:Ye,shrSH:De,shrSL:Ge,rotrSH:We,rotrSL:Xe,rotrBH:Qe,rotrBL:Je,rotr32H:Fe,rotr32L:tn,rotlSH:ge,rotlSL:we,rotlBH:be,rotlBL:ye,add:en,add3L:nn,add3H:rn,add4L:on,add4H:sn,add5H:fn,add5L:cn},Er=an;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const me=BigInt(0),Ot=BigInt(1),un=BigInt(2);function Y(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}const ln=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function dt(t){if(!Y(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=ln[t[e]];return n}function pe(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function Pt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const W={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Jt(t){if(t>=W._0&&t<=W._9)return t-W._0;if(t>=W._A&&t<=W._F)return t-(W._A-10);if(t>=W._a&&t<=W._f)return t-(W._a-10)}function ht(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let o=0,s=0;o<e;o++,s+=2){const c=Jt(t.charCodeAt(s)),i=Jt(t.charCodeAt(s+1));if(c===void 0||i===void 0){const f=t[s]+t[s+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+s)}r[o]=c*16+i}return r}function Z(t){return Pt(dt(t))}function zt(t){if(!Y(t))throw new Error("Uint8Array expected");return Pt(dt(Uint8Array.from(t).reverse()))}function nt(t,n){return ht(t.toString(16).padStart(n*2,"0"))}function jt(t,n){return nt(t,n).reverse()}function dn(t){return ht(pe(t))}function $(t,n,e){let r;if(typeof n=="string")try{r=ht(n)}catch(s){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${s}`)}else if(Y(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function M(...t){let n=0;for(let o=0;o<t.length;o++){const s=t[o];if(!Y(s))throw new Error("Uint8Array expected");n+=s.length}let e=new Uint8Array(n),r=0;for(let o=0;o<t.length;o++){const s=t[o];e.set(s,r),r+=s.length}return e}function hn(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function kt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function gn(t){let n;for(n=0;t>me;t>>=Ot,n+=1);return n}function wn(t,n){return t>>BigInt(n)&Ot}const bn=(t,n,e)=>t|(e?Ot:me)<<BigInt(n),Mt=t=>(un<<BigInt(t-1))-Ot,Tt=t=>new Uint8Array(t),Ft=t=>Uint8Array.from(t);function Ee(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Tt(t),o=Tt(t),s=0;const c=()=>{r.fill(1),o.fill(0),s=0},i=(...l)=>e(o,r,...l),f=(l=Tt())=>{o=i(Ft([0]),l),r=i(),l.length!==0&&(o=i(Ft([1]),l),r=i())},a=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const _=[];for(;l<n;){r=i();const B=r.slice();_.push(B),l+=r.length}return M(..._)};return(l,_)=>{c(),f(l);let B;for(;!(B=_(a()));)f();return c(),B}}const yn={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||Y(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function gt(t,n,e={}){const r=(o,s,c)=>{const i=yn[s];if(typeof i!="function")throw new Error(`Invalid validator "${s}", expected function`);const f=t[o];if(!(c&&f===void 0)&&!i(f,t))throw new Error(`Invalid param ${String(o)}=${f} (${typeof f}), expected ${s}`)};for(const[o,s]of Object.entries(n))r(o,s,!1);for(const[o,s]of Object.entries(e))r(o,s,!0);return t}const mn=Object.freeze(Object.defineProperty({__proto__:null,bitGet:wn,bitLen:gn,bitMask:Mt,bitSet:bn,bytesToHex:dt,bytesToNumberBE:Z,bytesToNumberLE:zt,concatBytes:M,createHmacDrbg:Ee,ensureBytes:$,equalBytes:hn,hexToBytes:ht,hexToNumber:Pt,isBytes:Y,numberToBytesBE:nt,numberToBytesLE:jt,numberToHexUnpadded:pe,numberToVarBytesBE:dn,utf8ToBytes:kt,validateObject:gt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const R=BigInt(0),N=BigInt(1),it=BigInt(2),pn=BigInt(3),$t=BigInt(4),te=BigInt(5),ee=BigInt(8);BigInt(9);BigInt(16);function H(t,n){const e=t%n;return e>=R?e:n+e}function En(t,n,e){if(e<=R||n<R)throw new Error("Expected power/modulo > 0");if(e===N)return R;let r=N;for(;n>R;)n&N&&(r=r*t%e),t=t*t%e,n>>=N;return r}function K(t,n,e){let r=t;for(;n-- >R;)r*=r,r%=e;return r}function Ct(t,n){if(t===R||n<=R)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=H(t,n),r=n,o=R,s=N;for(;e!==R;){const i=r/e,f=r%e,a=o-s*i;r=e,e=f,o=s,s=a}if(r!==N)throw new Error("invert: does not exist");return H(o,n)}function Bn(t){const n=(t-N)/it;let e,r,o;for(e=t-N,r=0;e%it===R;e/=it,r++);for(o=it;o<t&&En(o,n,t)!==t-N;o++);if(r===1){const c=(t+N)/$t;return function(f,a){const g=f.pow(a,c);if(!f.eql(f.sqr(g),a))throw new Error("Cannot find square root");return g}}const s=(e+N)/it;return function(i,f){if(i.pow(f,n)===i.neg(i.ONE))throw new Error("Cannot find square root");let a=r,g=i.pow(i.mul(i.ONE,o),e),l=i.pow(f,s),_=i.pow(f,e);for(;!i.eql(_,i.ONE);){if(i.eql(_,i.ZERO))return i.ZERO;let B=1;for(let u=i.sqr(_);B<a&&!i.eql(u,i.ONE);B++)u=i.sqr(u);const m=i.pow(g,N<<BigInt(a-B-1));g=i.sqr(m),l=i.mul(l,m),_=i.mul(_,g),a=B}return l}}function xn(t){if(t%$t===pn){const n=(t+N)/$t;return function(r,o){const s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%ee===te){const n=(t-te)/ee;return function(r,o){const s=r.mul(o,it),c=r.pow(s,n),i=r.mul(o,c),f=r.mul(r.mul(i,it),c),a=r.mul(i,r.sub(f,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return Bn(t)}const Br=(t,n)=>(H(t,n)&N)===N,vn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Be(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=vn.reduce((r,o)=>(r[o]="function",r),n);return gt(t,e)}function Sn(t,n,e){if(e<R)throw new Error("Expected power > 0");if(e===R)return t.ONE;if(e===N)return n;let r=t.ONE,o=n;for(;e>R;)e&N&&(r=t.mul(r,o)),o=t.sqr(o),e>>=N;return r}function _n(t,n){const e=new Array(n.length),r=n.reduce((s,c,i)=>t.is0(c)?s:(e[i]=s,t.mul(s,c)),t.ONE),o=t.inv(r);return n.reduceRight((s,c,i)=>t.is0(c)?s:(e[i]=t.mul(s,e[i]),t.mul(s,c)),o),e}function xe(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function In(t,n,e=!1,r={}){if(t<=R)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=xe(t,n);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=xn(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:Mt(o),ZERO:R,ONE:N,create:f=>H(f,t),isValid:f=>{if(typeof f!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);return R<=f&&f<t},is0:f=>f===R,isOdd:f=>(f&N)===N,neg:f=>H(-f,t),eql:(f,a)=>f===a,sqr:f=>H(f*f,t),add:(f,a)=>H(f+a,t),sub:(f,a)=>H(f-a,t),mul:(f,a)=>H(f*a,t),pow:(f,a)=>Sn(i,f,a),div:(f,a)=>H(f*Ct(a,t),t),sqrN:f=>f*f,addN:(f,a)=>f+a,subN:(f,a)=>f-a,mulN:(f,a)=>f*a,inv:f=>Ct(f,t),sqrt:r.sqrt||(f=>c(i,f)),invertBatch:f=>_n(i,f),cmov:(f,a,g)=>g?a:f,toBytes:f=>e?jt(f,s):nt(f,s),fromBytes:f=>{if(f.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${f.length}`);return e?zt(f):Z(f)}});return Object.freeze(i)}function xr(t,n){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const e=t.sqrt(n);return t.isOdd(e)?t.neg(e):e}function ve(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function Se(t){const n=ve(t);return n+Math.ceil(n/2)}function An(t,n,e=!1){const r=t.length,o=ve(n),s=Se(n);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const c=e?Z(t):zt(t),i=H(c,n-N)+N;return e?jt(i,o):nt(i,o)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const On=BigInt(0),Ht=BigInt(1);function kn(t,n){const e=(o,s)=>{const c=s.negate();return o?c:s},r=o=>{const s=Math.ceil(n/o)+1,c=2**(o-1);return{windows:s,windowSize:c}};return{constTimeNegate:e,unsafeLadder(o,s){let c=t.ZERO,i=o;for(;s>On;)s&Ht&&(c=c.add(i)),i=i.double(),s>>=Ht;return c},precomputeWindow(o,s){const{windows:c,windowSize:i}=r(s),f=[];let a=o,g=a;for(let l=0;l<c;l++){g=a,f.push(g);for(let _=1;_<i;_++)g=g.add(a),f.push(g);a=g.double()}return f},wNAF(o,s,c){const{windows:i,windowSize:f}=r(o);let a=t.ZERO,g=t.BASE;const l=BigInt(2**o-1),_=2**o,B=BigInt(o);for(let m=0;m<i;m++){const u=m*f;let h=Number(c&l);c>>=B,h>f&&(h-=_,c+=Ht);const d=u,b=u+Math.abs(h)-1,p=m%2!==0,v=h<0;h===0?g=g.add(e(p,s[d])):a=a.add(e(v,s[b]))}return{p:a,f:g}},wNAFCached(o,s,c,i){const f=o._WINDOW_SIZE||1;let a=s.get(o);return a||(a=this.precomputeWindow(o,f),f!==1&&s.set(o,i(a))),this.wNAF(f,a,c)}}}function _e(t){return Be(t.Fp),gt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...xe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function qn(t){if(Y(t))return t;if(typeof t=="string")return kt(t);throw new Error("DST must be Uint8Array or string")}const Ln=Z;function et(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function Nn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function yt(t){if(!Y(t))throw new Error("Uint8Array expected")}function Kt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Tn(t,n,e,r){yt(t),yt(n),Kt(e),n.length>255&&(n=r(M(kt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:s}=r,c=Math.ceil(e/o);if(c>255)throw new Error("Invalid xmd length");const i=M(n,et(n.length,1)),f=et(0,s),a=et(e,2),g=new Array(c),l=r(M(f,t,a,et(0,1),i));g[0]=r(M(l,et(1,1),i));for(let B=1;B<=c;B++){const m=[Nn(l,g[B-1]),et(B+1,1),i];g[B]=r(M(...m))}return M(...g).slice(0,e)}function Hn(t,n,e,r,o){if(yt(t),yt(n),Kt(e),n.length>255){const s=Math.ceil(2*r/8);n=o.create({dkLen:s}).update(kt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(et(e,2)).update(n).update(et(n.length,1)).digest()}function ne(t,n,e){gt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:c,expand:i,DST:f}=e;yt(t),Kt(n);const a=qn(f),g=r.toString(2).length,l=Math.ceil((g+o)/8),_=n*s*l;let B;if(i==="xmd")B=Tn(t,a,_,c);else if(i==="xof")B=Hn(t,a,_,o,c);else if(i==="_internal_pass")B=t;else throw new Error('expand must be "xmd" or "xof"');const m=new Array(n);for(let u=0;u<n;u++){const h=new Array(s);for(let d=0;d<s;d++){const b=l*(d+u*s),p=B.subarray(b,b+l);h[d]=H(Ln(p),r)}m[u]=h}return m}function Un(t,n){const e=n.map(r=>Array.from(r).reverse());return(r,o)=>{const[s,c,i,f]=e.map(a=>a.reduce((g,l)=>t.add(t.mul(g,r),l)));return r=t.div(s,c),o=t.mul(o,t.div(i,f)),{x:r,y:o}}}function Rn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=ne(r,2,{...e,DST:e.DST,...o}),c=t.fromAffine(n(s[0])),i=t.fromAffine(n(s[1])),f=c.add(i).clearCofactor();return f.assertValidity(),f},encodeToCurve(r,o){const s=ne(r,1,{...e,DST:e.encodeDST,...o}),c=t.fromAffine(n(s[0])).clearCofactor();return c.assertValidity(),c}}}const[Ie,Ae,Oe]=[[],[],[]],$n=BigInt(0),bt=BigInt(1),Cn=BigInt(2),Zn=BigInt(7),Vn=BigInt(256),Pn=BigInt(113);for(let t=0,n=bt,e=1,r=0;t<24;t++){[e,r]=[r,(2*e+3*r)%5],Ie.push(2*(5*r+e)),Ae.push((t+1)*(t+2)/2%64);let o=$n;for(let s=0;s<7;s++)n=(n<<bt^(n>>Zn)*Pn)%Vn,n&Cn&&(o^=bt<<(bt<<BigInt(s))-bt);Oe.push(o)}const[zn,jn]=he(Oe,!0),re=(t,n,e)=>e>32?be(t,n,e):ge(t,n,e),oe=(t,n,e)=>e>32?ye(t,n,e):we(t,n,e);function ke(t,n=24){const e=new Uint32Array(10);for(let r=24-n;r<24;r++){for(let c=0;c<10;c++)e[c]=t[c]^t[c+10]^t[c+20]^t[c+30]^t[c+40];for(let c=0;c<10;c+=2){const i=(c+8)%10,f=(c+2)%10,a=e[f],g=e[f+1],l=re(a,g,1)^e[i],_=oe(a,g,1)^e[i+1];for(let B=0;B<50;B+=10)t[c+B]^=l,t[c+B+1]^=_}let o=t[2],s=t[3];for(let c=0;c<24;c++){const i=Ae[c],f=re(o,s,i),a=oe(o,s,i),g=Ie[c];o=t[g],s=t[g+1],t[g]=f,t[g+1]=a}for(let c=0;c<50;c+=10){for(let i=0;i<10;i++)e[i]=t[c+i];for(let i=0;i<10;i++)t[c+i]^=~e[(i+2)%10]&e[(i+4)%10]}t[0]^=zn[r],t[1]^=jn[r]}e.fill(0)}class pt extends fe{constructor(n,e,r,o=!1,s=24){if(super(),this.blockLen=n,this.suffix=e,this.outputLen=r,this.enableXOF=o,this.rounds=s,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,Qt(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=Pe(this.state)}keccak(){ke(this.state32,this.rounds),this.posOut=0,this.pos=0}update(n){xt(this);const{blockLen:e,state:r}=this;n=ae(n);const o=n.length;for(let s=0;s<o;){const c=Math.min(e-this.pos,o-s);for(let i=0;i<c;i++)r[this.pos++]^=n[s++];this.pos===e&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:n,suffix:e,pos:r,blockLen:o}=this;n[r]^=e,e&128&&r===o-1&&this.keccak(),n[o-1]^=128,this.keccak()}writeInto(n){xt(this,!1),ue(n),this.finish();const e=this.state,{blockLen:r}=this;for(let o=0,s=n.length;o<s;){this.posOut>=r&&this.keccak();const c=Math.min(r-this.posOut,s-o);n.set(e.subarray(this.posOut,this.posOut+c),o),this.posOut+=c,o+=c}return n}xofInto(n){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(n)}xof(n){return Qt(n),this.xofInto(new Uint8Array(n))}digestInto(n){if(ze(n,this),this.finished)throw new Error("digest() was already called");return this.writeInto(n),this.destroy(),n}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(n){const{blockLen:e,suffix:r,outputLen:o,rounds:s,enableXOF:c}=this;return n||(n=new pt(e,r,o,c,s)),n.state32.set(this.state32),n.pos=this.pos,n.posOut=this.posOut,n.finished=this.finished,n.rounds=s,n.suffix=r,n.outputLen=o,n.enableXOF=c,n.destroyed=this.destroyed,n}}const ot=(t,n,e)=>Ve(()=>new pt(n,t,e)),Mn=ot(6,144,224/8),Kn=ot(6,136,256/8),Yn=ot(6,104,384/8),Dn=ot(6,72,512/8),Gn=ot(1,144,224/8),Wn=ot(1,136,256/8),Xn=ot(1,104,384/8),Qn=ot(1,72,512/8),qe=(t,n,e)=>je((r={})=>new pt(n,t,r.dkLen===void 0?e:r.dkLen,!0)),Jn=qe(31,168,128/8),Fn=qe(31,136,256/8),vr=Object.freeze(Object.defineProperty({__proto__:null,Keccak:pt,keccakP:ke,keccak_224:Gn,keccak_256:Wn,keccak_384:Xn,keccak_512:Qn,sha3_224:Mn,sha3_256:Kn,sha3_384:Yn,sha3_512:Dn,shake128:Jn,shake256:Fn},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function tr(t){const n=_e(t);gt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:er,hexToBytes:nr}=mn,ct={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=ct;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:er(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=ct,e=typeof t=="string"?nr(t):t;if(!Y(e))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:o,l:s}=ct._parseInt(e.subarray(2)),{d:c,l:i}=ct._parseInt(s);if(i.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s:c}},hexFromSig(t){const n=a=>Number.parseInt(a[0],16)&8?"00"+a:a,e=a=>{const g=a.toString(16);return g.length&1?`0${g}`:g},r=n(e(t.s)),o=n(e(t.r)),s=r.length/2,c=o.length/2,i=e(s),f=e(c);return`30${e(c+s+4)}02${f}${o}02${i}${r}`}},G=BigInt(0),T=BigInt(1),tt=BigInt(2),St=BigInt(3),se=BigInt(4);function rr(t){const n=tr(t),{Fp:e}=n,r=n.toBytes||((m,u,h)=>{const d=u.toAffine();return M(Uint8Array.from([4]),e.toBytes(d.x),e.toBytes(d.y))}),o=n.fromBytes||(m=>{const u=m.subarray(1),h=e.fromBytes(u.subarray(0,e.BYTES)),d=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:h,y:d}});function s(m){const{a:u,b:h}=n,d=e.sqr(m),b=e.mul(d,m);return e.add(e.add(b,e.mul(m,u)),h)}if(!e.eql(e.sqr(n.Gy),s(n.Gx)))throw new Error("bad generator point: equation left != right");function c(m){return typeof m=="bigint"&&G<m&&m<n.n}function i(m){if(!c(m))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function f(m){const{allowedPrivateKeyLengths:u,nByteLength:h,wrapPrivateKey:d,n:b}=n;if(u&&typeof m!="bigint"){if(Y(m)&&(m=dt(m)),typeof m!="string"||!u.includes(m.length))throw new Error("Invalid key");m=m.padStart(h*2,"0")}let p;try{p=typeof m=="bigint"?m:Z($("private key",m,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof m}`)}return d&&(p=H(p,b)),i(p),p}const a=new Map;function g(m){if(!(m instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(u,h,d){if(this.px=u,this.py=h,this.pz=d,u==null||!e.isValid(u))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(d==null||!e.isValid(d))throw new Error("z required")}static fromAffine(u){const{x:h,y:d}=u||{};if(!u||!e.isValid(h)||!e.isValid(d))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");const b=p=>e.eql(p,e.ZERO);return b(h)&&b(d)?l.ZERO:new l(h,d,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const h=e.invertBatch(u.map(d=>d.pz));return u.map((d,b)=>d.toAffine(h[b])).map(l.fromAffine)}static fromHex(u){const h=l.fromAffine(o($("pointHex",u)));return h.assertValidity(),h}static fromPrivateKey(u){return l.BASE.multiply(f(u))}_setWindowSize(u){this._WINDOW_SIZE=u,a.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:u,y:h}=this.toAffine();if(!e.isValid(u)||!e.isValid(h))throw new Error("bad point: x or y not FE");const d=e.sqr(h),b=s(u);if(!e.eql(d,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){g(u);const{px:h,py:d,pz:b}=this,{px:p,py:v,pz:I}=u,E=e.eql(e.mul(h,I),e.mul(p,b)),x=e.eql(e.mul(d,I),e.mul(v,b));return E&&x}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:h}=n,d=e.mul(h,St),{px:b,py:p,pz:v}=this;let I=e.ZERO,E=e.ZERO,x=e.ZERO,S=e.mul(b,b),C=e.mul(p,p),L=e.mul(v,v),O=e.mul(b,p);return O=e.add(O,O),x=e.mul(b,v),x=e.add(x,x),I=e.mul(u,x),E=e.mul(d,L),E=e.add(I,E),I=e.sub(C,E),E=e.add(C,E),E=e.mul(I,E),I=e.mul(O,I),x=e.mul(d,x),L=e.mul(u,L),O=e.sub(S,L),O=e.mul(u,O),O=e.add(O,x),x=e.add(S,S),S=e.add(x,S),S=e.add(S,L),S=e.mul(S,O),E=e.add(E,S),L=e.mul(p,v),L=e.add(L,L),S=e.mul(L,O),I=e.sub(I,S),x=e.mul(L,C),x=e.add(x,x),x=e.add(x,x),new l(I,E,x)}add(u){g(u);const{px:h,py:d,pz:b}=this,{px:p,py:v,pz:I}=u;let E=e.ZERO,x=e.ZERO,S=e.ZERO;const C=n.a,L=e.mul(n.b,St);let O=e.mul(h,p),V=e.mul(d,v),P=e.mul(b,I),X=e.add(h,d),w=e.add(p,v);X=e.mul(X,w),w=e.add(O,V),X=e.sub(X,w),w=e.add(h,b);let y=e.add(p,I);return w=e.mul(w,y),y=e.add(O,P),w=e.sub(w,y),y=e.add(d,b),E=e.add(v,I),y=e.mul(y,E),E=e.add(V,P),y=e.sub(y,E),S=e.mul(C,w),E=e.mul(L,P),S=e.add(E,S),E=e.sub(V,S),S=e.add(V,S),x=e.mul(E,S),V=e.add(O,O),V=e.add(V,O),P=e.mul(C,P),w=e.mul(L,w),V=e.add(V,P),P=e.sub(O,P),P=e.mul(C,P),w=e.add(w,P),O=e.mul(V,w),x=e.add(x,O),O=e.mul(y,w),E=e.mul(X,E),E=e.sub(E,O),O=e.mul(X,V),S=e.mul(y,S),S=e.add(S,O),new l(E,x,S)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return B.wNAFCached(this,a,u,h=>{const d=e.invertBatch(h.map(b=>b.pz));return h.map((b,p)=>b.toAffine(d[p])).map(l.fromAffine)})}multiplyUnsafe(u){const h=l.ZERO;if(u===G)return h;if(i(u),u===T)return this;const{endo:d}=n;if(!d)return B.unsafeLadder(this,u);let{k1neg:b,k1:p,k2neg:v,k2:I}=d.splitScalar(u),E=h,x=h,S=this;for(;p>G||I>G;)p&T&&(E=E.add(S)),I&T&&(x=x.add(S)),S=S.double(),p>>=T,I>>=T;return b&&(E=E.negate()),v&&(x=x.negate()),x=new l(e.mul(x.px,d.beta),x.py,x.pz),E.add(x)}multiply(u){i(u);let h=u,d,b;const{endo:p}=n;if(p){const{k1neg:v,k1:I,k2neg:E,k2:x}=p.splitScalar(h);let{p:S,f:C}=this.wNAF(I),{p:L,f:O}=this.wNAF(x);S=B.constTimeNegate(v,S),L=B.constTimeNegate(E,L),L=new l(e.mul(L.px,p.beta),L.py,L.pz),d=S.add(L),b=C.add(O)}else{const{p:v,f:I}=this.wNAF(h);d=v,b=I}return l.normalizeZ([d,b])[0]}multiplyAndAddUnsafe(u,h,d){const b=l.BASE,p=(I,E)=>E===G||E===T||!I.equals(b)?I.multiplyUnsafe(E):I.multiply(E),v=p(this,h).add(p(u,d));return v.is0()?void 0:v}toAffine(u){const{px:h,py:d,pz:b}=this,p=this.is0();u==null&&(u=p?e.ONE:e.inv(b));const v=e.mul(h,u),I=e.mul(d,u),E=e.mul(b,u);if(p)return{x:e.ZERO,y:e.ZERO};if(!e.eql(E,e.ONE))throw new Error("invZ was invalid");return{x:v,y:I}}isTorsionFree(){const{h:u,isTorsionFree:h}=n;if(u===T)return!0;if(h)return h(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:h}=n;return u===T?this:h?h(l,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return this.assertValidity(),r(l,this,u)}toHex(u=!0){return dt(this.toRawBytes(u))}}l.BASE=new l(n.Gx,n.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);const _=n.nBitLength,B=kn(l,n.endo?Math.ceil(_/2):_);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:f,weierstrassEquation:s,isWithinCurveOrder:c}}function or(t){const n=_e(t);return gt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function sr(t){const n=or(t),{Fp:e,n:r}=n,o=e.BYTES+1,s=2*e.BYTES+1;function c(w){return G<w&&w<e.ORDER}function i(w){return H(w,r)}function f(w){return Ct(w,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:g,weierstrassEquation:l,isWithinCurveOrder:_}=rr({...n,toBytes(w,y,A){const q=y.toAffine(),k=e.toBytes(q.x),U=M;return A?U(Uint8Array.from([y.hasEvenY()?2:3]),k):U(Uint8Array.from([4]),k,e.toBytes(q.y))},fromBytes(w){const y=w.length,A=w[0],q=w.subarray(1);if(y===o&&(A===2||A===3)){const k=Z(q);if(!c(k))throw new Error("Point is not on curve");const U=l(k);let z=e.sqrt(U);const j=(z&T)===T;return(A&1)===1!==j&&(z=e.neg(z)),{x:k,y:z}}else if(y===s&&A===4){const k=e.fromBytes(q.subarray(0,e.BYTES)),U=e.fromBytes(q.subarray(e.BYTES,2*e.BYTES));return{x:k,y:U}}else throw new Error(`Point of length ${y} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),B=w=>dt(nt(w,n.nByteLength));function m(w){const y=r>>T;return w>y}function u(w){return m(w)?i(-w):w}const h=(w,y,A)=>Z(w.slice(y,A));class d{constructor(y,A,q){this.r=y,this.s=A,this.recovery=q,this.assertValidity()}static fromCompact(y){const A=n.nByteLength;return y=$("compactSignature",y,A*2),new d(h(y,0,A),h(y,A,2*A))}static fromDER(y){const{r:A,s:q}=ct.toSig($("DER",y));return new d(A,q)}assertValidity(){if(!_(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!_(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(y){return new d(this.r,this.s,y)}recoverPublicKey(y){const{r:A,s:q,recovery:k}=this,U=x($("msgHash",y));if(k==null||![0,1,2,3].includes(k))throw new Error("recovery id invalid");const z=k===2||k===3?A+n.n:A;if(z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=k&1?"03":"02",Q=a.fromHex(j+B(z)),J=f(z),ft=i(-U*J),wt=i(q*J),F=a.BASE.multiplyAndAddUnsafe(Q,ft,wt);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return m(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return ht(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ht(this.toCompactHex())}toCompactHex(){return B(this.r)+B(this.s)}}const b={isValidPrivateKey(w){try{return g(w),!0}catch{return!1}},normPrivateKeyToScalar:g,randomPrivateKey:()=>{const w=Se(n.n);return An(n.randomBytes(w),n.n)},precompute(w=8,y=a.BASE){return y._setWindowSize(w),y.multiply(BigInt(3)),y}};function p(w,y=!0){return a.fromPrivateKey(w).toRawBytes(y)}function v(w){const y=Y(w),A=typeof w=="string",q=(y||A)&&w.length;return y?q===o||q===s:A?q===2*o||q===2*s:w instanceof a}function I(w,y,A=!0){if(v(w))throw new Error("first arg must be private key");if(!v(y))throw new Error("second arg must be public key");return a.fromHex(y).multiply(g(w)).toRawBytes(A)}const E=n.bits2int||function(w){const y=Z(w),A=w.length*8-n.nBitLength;return A>0?y>>BigInt(A):y},x=n.bits2int_modN||function(w){return i(E(w))},S=Mt(n.nBitLength);function C(w){if(typeof w!="bigint")throw new Error("bigint expected");if(!(G<=w&&w<S))throw new Error(`bigint expected < 2^${n.nBitLength}`);return nt(w,n.nByteLength)}function L(w,y,A=O){if(["recovered","canonical"].some(st=>st in A))throw new Error("sign() legacy options not supported");const{hash:q,randomBytes:k}=n;let{lowS:U,prehash:z,extraEntropy:j}=A;U==null&&(U=!0),w=$("msgHash",w),z&&(w=$("prehashed msgHash",q(w)));const Q=x(w),J=g(y),ft=[C(J),C(Q)];if(j!=null){const st=j===!0?k(e.BYTES):j;ft.push($("extraEntropy",st))}const wt=M(...ft),F=Q;function Nt(st){const at=E(st);if(!_(at))return;const Gt=f(at),ut=a.BASE.multiply(at).toAffine(),D=i(ut.x);if(D===G)return;const lt=i(Gt*i(F+D*J));if(lt===G)return;let Wt=(ut.x===D?0:2)|Number(ut.y&T),Xt=lt;return U&&m(lt)&&(Xt=u(lt),Wt^=1),new d(D,Xt,Wt)}return{seed:wt,k2sig:Nt}}const O={lowS:n.lowS,prehash:!1},V={lowS:n.lowS,prehash:!1};function P(w,y,A=O){const{seed:q,k2sig:k}=L(w,y,A),U=n;return Ee(U.hash.outputLen,U.nByteLength,U.hmac)(q,k)}a.BASE._setWindowSize(8);function X(w,y,A,q=V){var ut;const k=w;if(y=$("msgHash",y),A=$("publicKey",A),"strict"in q)throw new Error("options.strict was renamed to lowS");const{lowS:U,prehash:z}=q;let j,Q;try{if(typeof k=="string"||Y(k))try{j=d.fromDER(k)}catch(D){if(!(D instanceof ct.Err))throw D;j=d.fromCompact(k)}else if(typeof k=="object"&&typeof k.r=="bigint"&&typeof k.s=="bigint"){const{r:D,s:lt}=k;j=new d(D,lt)}else throw new Error("PARSE");Q=a.fromHex(A)}catch(D){if(D.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(U&&j.hasHighS())return!1;z&&(y=n.hash(y));const{r:J,s:ft}=j,wt=x(y),F=f(ft),Nt=i(wt*F),st=i(J*F),at=(ut=a.BASE.multiplyAndAddUnsafe(Q,Nt,st))==null?void 0:ut.toAffine();return at?i(at.x)===J:!1}return{CURVE:n,getPublicKey:p,getSharedSecret:I,sign:P,verify:X,ProjectivePoint:a,Signature:d,utils:b}}function ir(t,n){const e=t.ORDER;let r=G;for(let m=e-T;m%tt===G;m/=tt)r+=T;const o=r,s=tt<<o-T-T,c=s*tt,i=(e-T)/c,f=(i-T)/tt,a=c-T,g=s,l=t.pow(n,i),_=t.pow(n,(i+T)/tt);let B=(m,u)=>{let h=l,d=t.pow(u,a),b=t.sqr(d);b=t.mul(b,u);let p=t.mul(m,b);p=t.pow(p,f),p=t.mul(p,d),d=t.mul(p,u),b=t.mul(p,m);let v=t.mul(b,d);p=t.pow(v,g);let I=t.eql(p,t.ONE);d=t.mul(b,_),p=t.mul(v,h),b=t.cmov(d,b,I),v=t.cmov(p,v,I);for(let E=o;E>T;E--){let x=E-tt;x=tt<<x-T;let S=t.pow(v,x);const C=t.eql(S,t.ONE);d=t.mul(b,h),h=t.mul(h,h),S=t.mul(v,h),b=t.cmov(d,b,C),v=t.cmov(S,v,C)}return{isValid:I,value:b}};if(t.ORDER%se===St){const m=(t.ORDER-St)/se,u=t.sqrt(t.neg(n));B=(h,d)=>{let b=t.sqr(d);const p=t.mul(h,d);b=t.mul(b,p);let v=t.pow(b,m);v=t.mul(v,p);const I=t.mul(v,u),E=t.mul(t.sqr(v),d),x=t.eql(E,h);let S=t.cmov(I,v,x);return{isValid:x,value:S}}}return B}function cr(t,n){if(Be(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=ir(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,c,i,f,a,g,l;o=t.sqr(r),o=t.mul(o,n.Z),s=t.sqr(o),s=t.add(s,o),c=t.add(s,t.ONE),c=t.mul(c,n.B),i=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),i=t.mul(i,n.A),s=t.sqr(c),a=t.sqr(i),f=t.mul(a,n.A),s=t.add(s,f),s=t.mul(s,c),a=t.mul(a,i),f=t.mul(a,n.B),s=t.add(s,f),g=t.mul(o,c);const{isValid:_,value:B}=e(s,a);l=t.mul(o,r),l=t.mul(l,B),g=t.cmov(g,c,_),l=t.cmov(l,B,_);const m=t.isOdd(r)===t.isOdd(l);return l=t.cmov(t.neg(l),l,m),g=t.div(g,i),{x:g,y:l}}}class Le extends fe{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Me(n);const r=ae(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=n.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),s.fill(0)}update(n){return xt(this),this.iHash.update(n),this}digestInto(n){xt(this),ue(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:c,outputLen:i}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=c,n.outputLen=i,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Ne=(t,n,e)=>new Le(t,n).update(e).digest();Ne.create=(t,n)=>new Le(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function fr(t){return{hash:t,hmac:(n,...e)=>Ne(t,n,Ke(...e)),randomBytes:le}}function ar(t,n){const e=r=>sr({...t,...fr(r)});return Object.freeze({...e(n),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),_t=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Te=BigInt(1),It=BigInt(2),ie=(t,n)=>(t+n/It)/n;function He(t){const n=qt,e=BigInt(3),r=BigInt(6),o=BigInt(11),s=BigInt(22),c=BigInt(23),i=BigInt(44),f=BigInt(88),a=t*t*t%n,g=a*a*t%n,l=K(g,e,n)*g%n,_=K(l,e,n)*g%n,B=K(_,It,n)*a%n,m=K(B,o,n)*B%n,u=K(m,s,n)*m%n,h=K(u,i,n)*u%n,d=K(h,f,n)*h%n,b=K(d,i,n)*u%n,p=K(b,e,n)*g%n,v=K(p,c,n)*m%n,I=K(v,r,n)*a%n,E=K(I,It,n);if(!rt.eql(rt.sqr(E),t))throw new Error("Cannot find square root");return E}const rt=In(qt,void 0,void 0,{sqrt:He}),Et=ar({a:BigInt(0),b:BigInt(7),Fp:rt,n:_t,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const n=_t,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Te*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),s=e,c=BigInt("0x100000000000000000000000000000000"),i=ie(s*t,n),f=ie(-r*t,n);let a=H(t-i*e-f*o,n),g=H(-i*r-f*s,n);const l=a>c,_=g>c;if(l&&(a=n-a),_&&(g=n-g),a>c||g>c)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:a,k2neg:_,k2:g}}}},vt),Lt=BigInt(0),Ue=t=>typeof t=="bigint"&&Lt<t&&t<qt,ur=t=>typeof t=="bigint"&&Lt<t&&t<_t,ce={};function At(t,...n){let e=ce[t];if(e===void 0){const r=vt(Uint8Array.from(t,o=>o.charCodeAt(0)));e=M(r,r),ce[t]=e}return vt(M(e,...n))}const Yt=t=>t.toRawBytes(!0).slice(1),Zt=t=>nt(t,32),Ut=t=>H(t,qt),mt=t=>H(t,_t),Dt=Et.ProjectivePoint,lr=(t,n,e)=>Dt.BASE.multiplyAndAddUnsafe(t,n,e);function Vt(t){let n=Et.utils.normPrivateKeyToScalar(t),e=Dt.fromPrivateKey(n);return{scalar:e.hasEvenY()?n:mt(-n),bytes:Yt(e)}}function Re(t){if(!Ue(t))throw new Error("bad x: need 0 < x < p");const n=Ut(t*t),e=Ut(n*t+BigInt(7));let r=He(e);r%It!==Lt&&(r=Ut(-r));const o=new Dt(t,r,Te);return o.assertValidity(),o}function $e(...t){return mt(Z(At("BIP0340/challenge",...t)))}function dr(t){return Vt(t).bytes}function hr(t,n,e=le(32)){const r=$("message",t),{bytes:o,scalar:s}=Vt(n),c=$("auxRand",e,32),i=Zt(s^Z(At("BIP0340/aux",c))),f=At("BIP0340/nonce",i,o,r),a=mt(Z(f));if(a===Lt)throw new Error("sign failed: k is zero");const{bytes:g,scalar:l}=Vt(a),_=$e(g,o,r),B=new Uint8Array(64);if(B.set(g,0),B.set(Zt(mt(l+_*s)),32),!Ce(B,r,o))throw new Error("sign: Invalid signature produced");return B}function Ce(t,n,e){const r=$("signature",t,64),o=$("message",n),s=$("publicKey",e,32);try{const c=Re(Z(s)),i=Z(r.subarray(0,32));if(!Ue(i))return!1;const f=Z(r.subarray(32,64));if(!ur(f))return!1;const a=$e(Zt(i),Yt(c),o),g=lr(c,f,mt(-a));return!(!g||!g.hasEvenY()||g.toAffine().x!==i)}catch{return!1}}const gr=(()=>({getPublicKey:dr,sign:hr,verify:Ce,utils:{randomPrivateKey:Et.utils.randomPrivateKey,lift_x:Re,pointToBytes:Yt,numberToBytesBE:nt,bytesToNumberBE:Z,taggedHash:At,mod:H}}))(),wr=(()=>Un(rt,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map(t=>t.map(n=>BigInt(n)))))(),br=(()=>cr(rt,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:rt.create(BigInt("-11"))}))(),Ze=(()=>Rn(Et.ProjectivePoint,t=>{const{x:n,y:e}=br(rt.create(t[0]));return wr(n,e)},{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:rt.ORDER,m:1,k:128,expand:"xmd",hash:vt}))(),yr=(()=>Ze.hashToCurve)(),mr=(()=>Ze.encodeToCurve)(),_r=Object.freeze(Object.defineProperty({__proto__:null,encodeToCurve:mr,hashToCurve:yr,schnorr:gr,secp256k1:Et},Symbol.toStringTag,{value:"Module"}));export{In as F,gt as a,zt as b,dt as c,M as d,$ as e,xr as f,_r as g,vr as h,Br as i,Wn as k,H as m,jt as n,K as p,Et as s,Er as u,_e as v,kn as w};
